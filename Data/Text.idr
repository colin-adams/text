module Data.Text

import Data.Text.Encoding
import Data.Text.Encoding.UTF8

%access public
%default total

record EncodedString : Encoding -> Type where
  EncS :
    (getBytes_ : ByteString)
    -> EncodedString e

-- Required because the autogenerated projection is not very useful.
getBytes : EncodedString e -> ByteString
getBytes (EncS bs) = bs

-- We define Text to be UTF8-encoded packed strings.
Text : Type
Text = EncodedString UTF8

-- Meant to be used infix: ("bytes" `asEncodedIn` UTF8)
asEncodedIn : ByteString -> (e : Encoding) -> EncodedString e
asEncodedIn bs e = EncS bs

fromUTF8 : ByteString -> Text
fromUTF8 s = s `asEncodedIn` UTF8

private
foldr' :
  (ByteString -> Maybe (CodePoint, Nat))  -- The peek function
  -> (CodePoint -> a -> a)  -- The folding function
  -> a            -- The seed value
  -> Nat          -- Skip this number of bytes first
  -> Nat          -- Total string length
  -> ByteString   -- The bytes
  -> a
foldr' pE f z    Z     Z  bs = z
foldr' pE f z (S n)    Z  bs = z

foldr' pE f z (S n) (S l) bs with (unconsBS bs)  -- skip step
  | Nothing      = z
  | Just (x, xs) = foldr' pE f z n l xs

foldr' pE f z    Z  (S l) bs =
  case pE bs of
    Nothing        => z
    Just (c, skip) => f c $ case unconsBS bs of
      Nothing      => z
      Just (x, xs) => foldr' pE f z skip l xs

foldr : {e : Encoding} -> (CodePoint -> a -> a) -> a -> EncodedString e -> a
foldr {e = Enc pE _} f z (EncS bs) = foldr' pE f z 0 (lengthBS bs) bs

private
unpack' :
  (ByteString -> Maybe (CodePoint, Nat))  -- The peek function
  -> Nat          -- Skip this number of bytes first
  -> Nat          -- Total string length
  -> ByteString   -- The bytes
  -> List CodePoint
unpack' pE    Z     Z  bytes = []
unpack' pE (S n)    Z  bytes = []
unpack' pE (S n) (S l) bytes with (unconsBS bytes)
  | Nothing      = []
  | Just (x, xs) = unpack' pE n l xs
unpack' pE    Z  (S l) bytes with (pE bytes)
  | Nothing        | x = []
  | Just (c, skip) with (unconsBS bytes)
    | Nothing      = c :: []
    | Just (x, xs) = c :: unpack' pE skip l xs

unpack : {e : Encoding} -> EncodedString e -> List CodePoint
unpack {e = Enc pE _} = Data.Text.foldr (::) []

pack : {e : Encoding} -> List CodePoint -> EncodedString e
pack {e = Enc _ eE} = EncS . foldr (appendBS . eE) emptyBS

instance Cast (EncodedString e) (EncodedString e') where
  cast = pack . unpack

-- O(1). Construct a single-char encoded string.
singleton : {e : Encoding} -> CodePoint -> EncodedString e
singleton {e = Enc _ eE} c = EncS (eE c)

empty : EncodedString e
empty = EncS emptyBS

cons : {e : Encoding} -> CodePoint -> EncodedString e -> EncodedString e
cons {e = Enc pE eE} c (EncS bs) = EncS (eE c `appendBS` bs)

uncons : {e : Encoding} -> EncodedString e -> Maybe (CodePoint, EncodedString e)
uncons {e = Enc pE eE} (EncS bs) with (pE bs)
  | Just (c, skip) = Just (c, EncS $ dropBS skip bs)
  | Nothing        = Nothing

snoc : {e : Encoding} -> CodePoint -> EncodedString e -> EncodedString e
snoc {e = Enc pE eE} c (EncS bs) = EncS (bs `appendBS` eE c)

head : {e : Encoding} -> EncodedString e -> Maybe CodePoint
head {e = Enc pE eE} = map fst . pE . getBytes

tail : {e : Encoding} -> EncodedString e -> Maybe (EncodedString e)
tail {e = Enc pE eE} = map snd . uncons

-- TODO: length, last
